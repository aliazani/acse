/// @file options.c

#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include "utils.h"
#include "acse.h"
#include "target_info.h"
#include "program.h"
#include "utils.h"
#include "cflow_graph.h"
#include "target_asm_print.h"
#include "target_transform.h"
#include "target_info.h"
#include "cflow_graph.h"
#include "reg_alloc.h"
#include "parser.h"

typedef struct t_options {
  const char *outputFileName;
  const char *inputFileName;
} t_options;
t_options compilerOptions;

int num_error;

/* generated by the makefile */
extern const char *axe_version;

static const char *errorToString(int errorcode)
{
  const char *msg;

  switch (errorcode) {
    case ERROR_OUT_OF_MEMORY:
      msg = "Out of memory";
      break;
    case ERROR_INVALID_REGISTER_IDENTIFIER:
      msg = "Compiler bug, invalid register identifier";
      break;
    case ERROR_INVALID_INSTRUCTION:
      msg = "Invalid instruction";
      break;
    case ERROR_VARIABLE_ALREADY_DECLARED:
      msg = "Variable already declared";
      break;
    case ERROR_INVALID_TYPE:
      msg = "Invalid type";
      break;
    case ERROR_FOPEN_ERROR:
      msg = "fopen failed";
      break;
    case ERROR_FCLOSE_ERROR:
      msg = "fclose failed";
      break;
    case ERROR_FWRITE_ERROR:
      msg = "Error while writing on file";
      break;
    case ERROR_INVALID_DATA_FORMAT:
      msg = "Invalid data format";
      break;
    case ERROR_INVALID_OPCODE:
      msg = "Invalid opcode found";
      break;
    case ERROR_INVALID_ARRAY_SIZE:
      msg = "Invalid array size";
      break;
    case ERROR_INVALID_EXPRESSION:
      msg = "Invalid expression found";
      break;
    case ERROR_LABEL_ALREADY_ASSIGNED:
      msg = "label already assigned";
      break;
    case ERROR_INVALID_CFLOW_GRAPH:
      msg = "Invalid control-dataflow graph informations";
      break;
    case ERROR_INVALID_REG_ALLOC:
      msg = "Invalid register allocator instance found";
      break;
    case ERROR_REG_ALLOC_ERROR:
      msg = "register allocation failed";
      break;
    case ERROR_VARIABLE_TYPE_MISMATCH:
      msg = "type of the variable does not match";
      break;
    default:
      msg = "Unknown error";
      break;
  }

  return msg;
}

static const char *warningToString(int warningcode)
{
  const char *msg;

  switch (warningcode) {
    case WARN_DIVISION_BY_ZERO:
      msg = "division by zero";
      break;
    case WARN_INVALID_SHIFT_AMOUNT:
      msg = "shift amount is less than 0 or greater than 31";
      break;
    case WARN_OVERFLOW:
      msg = "overflow";
      break;
    default:
      msg = "<invalid warning>";
      break;
  }

  return msg;
}

static void printMessage(const char *msg, const char *category)
{
  if (line_num >= 0)
    fprintf(stderr, "At line %d, %s: %s.\n", line_num, category, msg);
  else
    fprintf(stderr, "%s: %s.\n", category, msg);
}

void emitError(int errorcode)
{
  const char *msg;

  /* Convert the error code to a string */
  msg = errorToString(errorcode);
  /* print out the error message to the standard error */
  printMessage(msg, "error");
  num_error++;
}

void emitWarning(int warningcode)
{
  const char *msg;

  /* Convert the warning code to a string */
  msg = warningToString(warningcode);
  /* print out the warning message to the standard error */
  printMessage(msg, "warning");
}

void emitSyntaxError(const char *message)
{
  /* print out the error message to the standard error */
  printMessage(message, "error");
  num_error++;
}

void fatalError(int errorcode)
{
  const char *msg;

  /* Convert the error code to a string */
  msg = errorToString(errorcode);
  /* print out the error message to the standard error */
  printMessage(msg, "fatal error");

  exit(1);
}


char *getLogFileName(const char *logType)
{
  char *outfn, *basename;
  size_t nameLen;
  int lastDot, i;

  basename = strdup(compilerOptions.outputFileName);
  if (!basename)
    fatalError(ERROR_OUT_OF_MEMORY);

  lastDot = -1;
  for (i = 0; basename[i] != '\0'; i++) {
    if (basename[i] == '.')
      lastDot = i;
  }
  if (lastDot >= 0)
    basename[lastDot] = '\0';

  nameLen = strlen(basename) + strlen(logType) + (size_t)8;
  outfn = calloc(nameLen, sizeof(char));
  if (!outfn)
    fatalError(ERROR_OUT_OF_MEMORY);

  snprintf(outfn, nameLen, "%s_%s.log", basename, logType);
  free(basename);
  return outfn;
}


void banner(void)
{
  printf("ACSE %s compiler, version %s\n", TARGET_NAME, axe_version);
}

void usage(const char *name)
{
  banner();
  printf("usage: %s [options] input\n\n", name);
  puts("Options:");
  puts("  -o ASMFILE    Name the output ASMFILE (default output.asm)");
  puts("  -h, --help    Displays available options");
}

int main(int argc, char *argv[])
{
  char *name = argv[0];
  int ch;
  static const struct option options[] = {
      {"help", no_argument, NULL, 'h'},
  };

  compilerOptions.inputFileName = NULL;
  compilerOptions.outputFileName = "output.asm";

  while ((ch = getopt_long(argc, argv, "ho:", options, NULL)) != -1) {
    switch (ch) {
      case 'o':
        compilerOptions.outputFileName = optarg;
        break;
      case 'h':
        usage(name);
        return 1;
      default:
        usage(name);
        return 1;
    }
  }
  argc -= optind;
  argv += optind;

  if (argc > 1) {
    fprintf(stderr, "Cannot compile more than one file, exiting.\n");
    return 1;
  } else if (argc == 1) {
    compilerOptions.inputFileName = argv[0];
  }

#ifndef NDEBUG
  banner();
  printf("\n");
#endif

  /* initialize the translation infos */
  program = newProgram();

  debugPrintf("Parsing the input program\n");
  /* Open the input file */
  FILE *fp;
  if (compilerOptions.inputFileName != NULL) {
    fp = fopen(compilerOptions.inputFileName, "r");
    if (fp == NULL)
      fatalError(ERROR_FOPEN_ERROR);
    debugPrintf(" -> Reading input from \"%s\"\n", compilerOptions.inputFileName);
  } else {
    fp = stdin;
    debugPrintf(" -> Reading from standard input\n");
  }
  int num_errors = parseProgram(program, fp);

  if (num_errors > 0) {
    /* Syntax errors have happened... */
    fprintf(stderr, "Input contains errors, no assembly file written.\n");
    fprintf(stderr, "%d error(s) found.\n", num_errors);
  } else {
    debugPrintf("Lowering of pseudo-instructions to machine instructions.\n");
    doTargetSpecificTransformations(program);

    debugPrintf("Performing register allocation.\n");
    doRegisterAllocation(program);

    debugPrintf("Writing the assembly file.\n");
    debugPrintf(" -> Output file name: \"%s\"\n", compilerOptions.outputFileName);
    fp = fopen(compilerOptions.outputFileName, "w");
    if (fp == NULL)
      fatalError(ERROR_FOPEN_ERROR);
    writeAssembly(program, fp);
  }
  
  debugPrintf("Finalizing the compiler data structures.\n");
  deleteProgram(program);

  debugPrintf("Done.\n");
  return 0;
}
